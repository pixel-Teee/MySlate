# 布局计算

## ComputeDesiredSize



保留绘制模式的UI计算布局，需要两次递归，一次是自顶向上计算固定的大小，一次是自上而下分配控件的大小给子控件，这是因为当控件的属性指定为填充的时候，会铺满父控件的槽，否则则使用自身的固定大小，比如图片可以要求填充或者本身的大小。



这是slate文档的描述，只有几句话，经过我的试验，重新写了一遍，Cache Desired Size(存储期望的大小)，这个就是固定大小，Compute Desired Size计算完毕后，调用Cache Desired Size，然后保存起来，待到Arrange Children分配布局的时候，如果SWidget指定为固定大小，那么就使用固定大小，否则使用填充，填充整个槽。

![](_static/Image/Slate/LayoutCalculate.png)

![](_static/Image/Slate/SlatePrepass.png)

这是计算固定大小的流程，在我照抄的Slate UI里面，它是遍历每个窗口，每个窗口一个控件树，从每个窗口开始递归计算固定大小，然后先计算子控件的固定大小，然后加起来，计算父控件的固定大小，**ComputeDesiredSize**是个虚函数，根据不同的SWidget进行重载。



我们看一下SImage的ComputeDesiredSize，SImage除了图片的固定大小，我们还能指定相应的固定大小。

```c++
FVector2D SImage::ComputeDesiredSize(float) const
{
	const FSlateBrush* ImageBrush = ImageAttribute.Get();//获取画刷上的图片
    
    //如果SImage指定了固定大小，那就使用固定大小，否则使用图片的固定大小
	if(ImageBrush != nullptr)
    {
        const TOptional<FVector2D>& CurrentSizeOverride = DesiredSizeOverrideAttribute.Get();
        
        return CurrentSizeOverride.IsSet() ? CurrentSizeOverride.GetValue() : ImageBrush->ImageSize;
    }
    return FVector2D::ZeroVector;
}
```



SWidget的绘制和布局都在Tick的最后面调用，UObject的逻辑处理都在前面，但是有时候UObject要获取UMG的控件的固定大小，但是此时还没算出来，或者是使用的上一帧的固定大小，调用SlatePrepass可以解决这个问题，不要太担心这个函数的性能，因为这个函数是递归算的，如果控件是很顶层，靠近屏幕的，只会算几层，就停下来。



我们看看SOverlay的ComputeDesiredSize。

SOverlay是层叠控件，它的固定大小是这样计算的：

```c++
FVector2D SOverlay::ComputeDesiredSize( float ) const
{
	FVector2D MaxSize(0,0);
    //直接遍历所有的槽，求固定大小的最大值
	for ( int32 ChildIndex=0; ChildIndex < Children.Num(); ++ChildIndex )
	{
		const FOverlaySlot& CurSlot = Children[ChildIndex];
		const EVisibility ChildVisibilty = CurSlot.GetWidget()->GetVisibility();
		if ( ChildVisibilty != EVisibility::Collapsed )
		{
			FVector2D ChildDesiredSize = CurSlot.GetWidget()->GetDesiredSize() + CurSlot.GetPadding().GetDesiredSize();
			MaxSize.X = FMath::Max( MaxSize.X, ChildDesiredSize.X );
			MaxSize.Y = FMath::Max( MaxSize.Y, ChildDesiredSize.Y );
		}
	}

	return MaxSize;
}
```

![](_static/Image/Slate/SOverlayIllustration.png)

它是这样的一个控件，红色框框是SOverlay，里面有两个控件SWidget1和SWidget2，一个叠在另一个身上，根据Widget在槽里面的顺序。



每个控件都会计算固定大小，根据它所重载的ComputeDesiredSize函数。



## ArrangeChildren

计算布局，这个是最重要的，这个会调用每个控件的虚函数OnArrangeChildren。



这个和Paint/OnPaint一样，ArrangeChildren不是虚函数，不会直接调用OnArrangeChildren，ArrangeChildren是SWidget基类的函数，OnArrangeChildren则由每个SWidget重载，



至于为啥这么做，因为虚函数的调用比较耗时，slate把控件的相同计算放置在非虚函数ArrangeChildren里面，再去调用OnArrangeChildren，处理不同控件的布局，Unreal很多东西都这么操作，比如类的继承，把一些公共的东西放在一起。



![](_static/Image/Slate/ArrangeChildren.png)

这个函数首先更新控件的所有属性，如果这个属性是可见的话，TSlateAttribute或者TAttribute这种，从委托的回调函数里面拿值，然后再调用虚函数OnArrangeChildren，分配具体的大小。



我们看一下SLeafWidget的OnArrangeChildren虚函数，这个是SImage的父类：

```c++
void SLeafWidget::OnArrangeChildren( const FGeometry& AllottedGeometry, FArrangedChildren& ArrangedChildren ) const
{
	// Nothing to arrange; Leaf Widgets do not have children.
}
```

因为SImage是叶子控件类型的，它没有槽，也不需要计算布局，所以这里是空的。



我们看一下经典的水平盒子布局SHorizontalBox类，它的OnArrangeChildren函数，这里，Slate将SHorizontalBox从SBoxPanel(盒子画板)类继承，然后重写了SHorizontalBox的OnArrangeChildren函数，针对水平和垂直分别调用不同的函数。



```c++
void SBoxPanel::OnArrangeChildren( const FGeometry& AllottedGeometry, FArrangedChildren& ArrangedChildren ) const
{
	if ( this->Orientation == EOrientation::Orient_Horizontal )
	{
        //计算水平方向的布局，将父控件的AllottedGeometry分配给所有子控件
		ArrangeChildrenAlong<EOrientation::Orient_Horizontal>(GSlateFlowDirection, this->Children, AllottedGeometry, ArrangedChildren );
	}
	else
	{
        //计算垂直方向的布局，将父控件的AllottedGeometry分配给所有子控件
		ArrangeChildrenAlong<EOrientation::Orient_Vertical>(GSlateFlowDirection, this->Children, AllottedGeometry, ArrangedChildren );
	}
}
```

AllottedGeometry是当前SBoxPanel的可分配大小，我们可以分配给它的子槽里面的所有控件，分配完毕后，存储在FArrangedChildren(已经分配的儿子)里面。



我们先介绍这两个类，FGeometry和FArrangedChildren，这两个，控件的几何信息，还有已经分配了几何信息的控件。



这两个对象是递归派发的，一开始是在SWindow的PaintSlowPath里面获取的，然后一路递归下去。

```c++
int32 SWindow::PaintSlowPath(const FSlateInvalidationContext& Context)
{
	HittestGrid->Clear();

	const FSlateRect WindowCullingBounds = GetClippingRectangleInWindow();
    //获取当前窗口的Layer，为0，最小的
	const int32 LayerId = 0;
    //获取当前窗口的几何信息，比如大小为1024 * 720
	const FGeometry WindowGeometry = GetWindowGeometryInWindow();

	int32 MaxLayerId = 0;

	//OutDrawElements.PushBatchPriortyGroup(*this);
	{
		//一路分配下去
		MaxLayerId = Paint(*Context.PaintArgs, WindowGeometry, WindowCullingBounds, *Context.WindowElementList, LayerId, Context.WidgetStyle, Context.bParentEnabled);
	}

	//OutDrawElements.PopBatchPriortyGroup();



	return MaxLayerId;
}
```

### FGeometry

这个类表示一个Widget的位置，大小，还有绝对位置在Slate中，注释这样描写到，总共5个属性比较重要，盘点一下：

```c++
const FVector2D Size;//大小

const float Scale;//缩放

const FVector2f AbsolutePosition;//绝对位置，以屏幕左上角为起点

const FVector2f Position;//相对位置，相对于父控件的坐标系

FSlateRenderTransform AccumulatedRenderTransform;//把上面的几个属性拼成一个矩阵的一个类
```

FGeometry里面的东西比较复杂，但是它的属性是比较简单的，FSlateRenderTransform表示数学概念上的变换，是一个2x2的矩阵。

在TransformCalculus2D.h这个头文件里面，定义了二维控件的很多类，比如FScale2D，FQuat2D，FTransform2D等，定义了很复杂的模板，去支持它们这些类可以互相连接起来，在Concatenate这个函数，比如一个缩放乘以一个旋转。



OnArrangeChildren用到这个参数，放在参数里面用以递归，主要是为了递归分配几何大小，比如一个大小的高度为4，分配给两个控件，垂直布局，那么这两个控件的高度大小则为2。



# FArrangedChildren

已经分配了几何信息的Children。



这个是个控件的数组，但是还存放了每个控件已经分配好的FGeometry几何信息。



FArrangedChildren，有一套类似数组的接口，可以看看，然后它有个FArrangedWidgetArray成员，就是FArrangedWidget的TArray。

FArrangedWidget就是分配好几何信息的SWidget，存了一个SWidget的共享指针以及一个FGeometry。



在调用OnArrangeChildren的时候，**把分配好布局的SWidget放入FArrangedWidget。**



我们来看看SBoxPanel的OnArrangeChildren函数里面的ArrangeChildrenAlong函数。



```c++
template<EOrientation Orientation, typename SlotType>
static void ArrangeChildrenAlong(EFlowDirection InLayoutFlow, const TPanelChildren<SlotType>& Children,
const FGeometry& AllottedGeometry, FArrangedChildren& ArrangedChildren)
{
	//开始分配
    
    //分配的控件将被给予固定大小的children第一步
    //剩下的控件将根据比例分配给拉伸的儿子(SizeRule_Stretch)
    //基于它们拉伸的因子
    if(Children.Num() > 0) //排列槽里面的widget，放入FArrangedChildren
    {
        float StretchCoefficientTotal = 0;//
    }
}
```



































