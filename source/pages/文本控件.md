# 文本

## 文本实现的概述
文本框和文本编辑框的实现很复杂，涉及到多个方面。涉及到字体文件的读取，字体图集的存储，字体的渲染，渲染的字体的排版、塑形。这些涉及到三个公用库，freetype、harfbuzz、icu。freetype负责字体文件的读取和转换为像素数据，harfbuzz负责字体的塑形，调整每个字之间的间隔，而icu负责断词断句以及语言本地化。

## 字体文件的读取
FSlateFontInfo表示字体文件相关的信息，后续freetype会获取这个FSlateFontInfo里面的字体文件名和字体大小去加载具体的字体文件。

FSlateFontInfo的字体可以是来自编辑器资产UAsset(这个是从ttf先转换到UAsset)，也可以是直接从硬盘上加载ttf，都是一样的，我们讲解ttf就可以，ttf文件名使用FCompositeFont存储，
FSlateFontInfo存储了一个FCompositeFont，这个FCompositeFont存了很多早期历史代码遗留的东西，但是其实只有文件名最重要。

然后是最关键的Size，字体大小用一个实际的物理尺寸描述，点(point)，1点表示1/72英寸，然后假定了设备的分辨率是96 dpi，即每英寸的像素数，所以一个字体的像素大小则是
字体点数(point) / 72英寸 * 96 dpi 即是像素数，为什么要假定设备分辨率？因为计算机实际上是不知道自己显示器的尺寸的，但是windows的设置上有个调节比例大小，默认是100%，我们可以通过windows的函数获取这个值，然后缩放我们的应用，windows希望我们的应用在100%的时候，假定了设备是96 dpi去做计算，但是其实我们可以乱整，比如乘以200 dpi，完全遵照我们的心愿。

字体需要明白一个道理，就是每种point大小，都需要从freetype重新光栅化一遍，将字体文件数据转换为可以使用的uin8数组像素数据，因为ttf存储了描述字体的数学公式，需要拜托freetype去转换数学公式到具体的像素数据，这个转换需要很多时间，所以Unreal的Slate做了很多cache。为啥不直接缩放呢？因为直接使用缩放矩阵，会导致字体出现锯齿，所以，为了渲染出来的字体的美观，就需要针对每种字体大小去重新调用freetype的函数获取对应的字体像素数据，然后存放到字体图集上。那10、11、12、13等等，都需要重新光栅化一遍？是的，没错，一个图集会存储同个字的不同大小都是可能的，那不会撑爆吗？不会的，因为整个应用字体的大小在应用退出之前，都不会发生改变，而且UE的策略是遇到了一个字，才去从ttf去获取这个字的像素数据，存放到图集里面。

那编辑器和运行时默认的字体文件都是从哪里开始定义和加载的？
是从样式的加载开始的，比如FCoreStyle，样式集合，每个模块启动的时候，都可以创建自己的样式，在自己的样式里面存储字体文件名大小相关的信息，![](_static/Image/Slate/FSlateFontInfo.png)，然后再通过样式中心的函数将每个单独的模块的样式放进样式中心，![](_static/Image/Slate/FSlateStyleRegistry.png)，
样式中心是什么东西呢？样式中心可以认为是样式管理器，引擎每帧都会检查里面的样式，然后看看控件是否使用样式管理器的样式，如果使用了，则加载具体的数据(只是针对图片)，字体则是遇到一个字的时候，先从样式中心获取字体style名对应的FSlateFontInfo，再调用FSlateRenderer的FontService类里面的freetype函数，去加载字体的像素数据，然后每帧在FSlateRenderer的FlushFontCache操作，字体图集会在C++的数据成员使用uint8存一份像素数据，然后再通过图形API将这份数据上传更新到具体的可以采样的图片对象上。

字体的加载，以及获取一个字相应的尺寸信息，都是通过FSlateFontServices这个类来进行的，这个类FSlateRenderer所持有的，是在FSlateRenderer创建的时候，new出来的。
FSlateFontService存放两个类数据成员，FSlateFontCache和FSlateFontMeasure，一个是存放从freetype加载的字体数据的缓存，一个是获取一个字的度量信息，字的度量信息是什么？字的度量信息，如下：
![](_static/Image/Slate/Font.png)，可以在freetype网站查阅，需要从freetype获取这些度量值去摆放一串字。


### 字体读取的位置
先讲解普通文本框，再讲解文本编辑框，文本框和文本编辑框有很大的区别。

字体的加载是在计算文本编辑框的固定大小的时候，计算的，在STextBlock::ComputeDesiredSize里面，调用TextLayoutCache(FSlateTextBlockLayout)的ComputeDesiredSize进行的，TextLayoutCache是什么呢？TextLayoutCache存放了一串文本经过\r\n换行符拆解后，存的每行的位置、大小、文本方向等信息。(还有一种是简单文本模式，这个后续讲解。)

FSlateTextBlockLayout类持有了FSlateTextLayout，ITextLayoutMarshaller(文本装配器)，这两个比较关键，还有一个高亮器，这个高亮器提供绘制高亮和下划线等操作。
FSlateTextLayout继承自FTextLayout，FTextLayout最重要，存放FLineModel数组和FLineView数组，一个FLineModel是经过\r\n划分的字符串的每部分(用FTextRange描述在文文本串的范围)，而FLineView是经过进一步处理，转换成可以用于渲染的数据，存放了这个块的高度，文本方向，在文本框的位置等信息，多个FLineView对应一个FLineModel。

而字体加载处于任何一处地方，比如获取一个字的BaseLine，![](_static/Image/Slate/GetBaseline2.png)![](_static/Image/Slate/GetBaseline.png)。
由于Application是个单例，可以随时随地获取FontMeasure。

这里的GetCharacterList，会将FSlateFontInfo、FontScale、描边设置作为key，创建一个类对象FSlateFontKey，然后用map管理FSlateFontKey对应的FCharacterList，
FCharacterList有一个map，存放每个字符对应FCharacterListEntry，这个FCharacterListEntry非常重要，拥有FShapedGlyphEntry，存放了一个字符的度量信息![](_static/Image/Slate/Metrics.png)，还有针对所有字体的baseline，maxheight。




