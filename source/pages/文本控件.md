# 文本

## 文本实现的概述
文本框和文本编辑框的实现很复杂，涉及到多个方面。涉及到字体文件的读取，字体图集的存储，字体的渲染，渲染的字体的排版、塑形。这些涉及到三个公用库，freetype、harfbuzz、icu。freetype负责字体文件的读取和转换为像素数据，harfbuzz负责字体的塑形，调整每个字之间的间隔，而icu负责断词断句以及语言本地化。

## 字体文件的读取
FSlateFontInfo表示字体文件相关的信息，后续freetype会获取这个FSlateFontInfo里面的字体文件名和字体大小去加载具体的字体文件。

FSlateFontInfo的字体可以是来自编辑器资产UAsset(这个是从ttf先转换到UAsset)，也可以是直接从硬盘上加载ttf，都是一样的，我们讲解ttf就可以，ttf文件名使用FCompositeFont存储，
FSlateFontInfo存储了一个FCompositeFont，这个FCompositeFont存了很多早期历史代码遗留的东西，但是其实只有文件名最重要。

然后是最关键的Size，字体大小用一个实际的物理尺寸描述，点(point)，1点表示1/72英寸，然后假定了设备的分辨率是96 dpi，即每英寸的像素数，所以一个字体的像素大小则是
字体点数(point) / 72英寸 * 96 dpi 即是像素数，为什么要假定设备分辨率？因为计算机实际上是不知道自己显示器的尺寸的，但是windows的设置上有个调节比例大小，默认是100%，我们可以通过windows的函数获取这个值，然后缩放我们的应用，windows希望我们的应用在100%的时候，假定了设备是96 dpi去做计算，但是其实我们可以乱整，比如乘以200 dpi，完全遵照我们的心愿。

字体需要明白一个道理，就是每种point大小，都需要从freetype重新光栅化一遍，将字体文件数据转换为可以使用的uin8数组像素数据，因为ttf存储了描述字体的数学公式，需要拜托freetype去转换数学公式到具体的像素数据，这个转换需要很多时间，所以Unreal的Slate做了很多cache。为啥不直接缩放呢？因为直接使用缩放矩阵，会导致字体出现锯齿，所以，为了渲染出来的字体的美观，就需要针对每种字体大小去重新调用freetype的函数获取对应的字体像素数据，然后存放到字体图集上。那10、11、12、13等等，都需要重新光栅化一遍？是的，没错，一个图集会存储同个字的不同大小都是可能的，那不会撑爆吗？不会的，因为整个应用字体的大小在应用退出之前，都不会发生改变，而且UE的策略是遇到了一个字，才去从ttf去获取这个字的像素数据，存放到图集里面。

那编辑器和运行时默认的字体文件都是从哪里开始定义和加载的？
是从样式的加载开始的，比如FCoreStyle，样式集合，每个模块启动的时候，都可以创建自己的样式，在自己的样式里面存储字体文件名大小相关的信息，![](_static/Image/Slate/FSlateFontInfo.png)，然后再通过样式中心的函数将每个单独的模块的样式放进样式中心，![](_static/Image/Slate/FSlateStyleRegistry.png)，
样式中心是什么东西呢？样式中心可以认为是样式管理器，引擎每帧都会检查里面的样式，然后看看控件是否使用样式管理器的样式，如果使用了，则加载具体的数据(只是针对图片)，字体则是遇到一个字的时候，先从样式中心获取字体style名对应的FSlateFontInfo，再调用FSlateRenderer的FontService类里面的freetype函数，去加载字体的像素数据，然后每帧在FSlateRenderer的FlushFontCache操作，字体图集会在C++的数据成员使用uint8存一份像素数据，然后再通过图形API将这份数据上传更新到具体的可以采样的图片对象上。





